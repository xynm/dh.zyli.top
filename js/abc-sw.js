!function (e) { var t = {}; function s(n) { if (t[n]) return t[n].exports; var r = t[n] = { i: n, l: !1, exports: {} }; return e[n].call(r.exports, r, r.exports, s), r.l = !0, r.exports } s.m = e, s.c = t, s.d = function (e, t, n) { s.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: n }) }, s.r = function (e) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, s.t = function (e, t) { if (1 & t && (e = s(e)), 8 & t) return e; if (4 & t && "object" == typeof e && e && e.__esModule) return e; var n = Object.create(null); if (s.r(n), Object.defineProperty(n, "default", { enumerable: !0, value: e }), 2 & t && "string" != typeof e) for (var r in e) s.d(n, r, function (t) { return e[t] }.bind(null, r)); return n }, s.n = function (e) { var t = e && e.__esModule ? function () { return e.default } : function () { return e }; return s.d(t, "a", t), t }, s.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) }, s.p = "https://sf1-scmcdn-tos.pstatp.com/goofy/pgcfe/mp/web/", s(s.s = 10) }([function (e, t, s) { "use strict"; try { self["workbox:precaching:6.1.1"] && _() } catch (e) { } }, function (e, t, s) { "use strict"; try { self["workbox:core:6.1.1"] && _() } catch (e) { } }, function (e, t, s) { "use strict"; try { self["workbox:routing:6.1.1"] && _() } catch (e) { } }, function (e, t, s) { "use strict"; try { self["workbox:strategies:6.1.1"] && _() } catch (e) { } }, function (e, t) { e.exports = function (e, t) { (null == t || t > e.length) && (t = e.length); for (var s = 0, n = new Array(t); s < t; s++)n[s] = e[s]; return n } }, function (e, t, s) { var n = s(6), r = s(7), a = s(8), i = s(9); e.exports = function (e) { return n(e) || r(e) || a(e) || i() } }, function (e, t, s) { var n = s(4); e.exports = function (e) { if (Array.isArray(e)) return n(e) } }, function (e, t) { e.exports = function (e) { if ("undefined" != typeof Symbol && Symbol.iterator in Object(e)) return Array.from(e) } }, function (e, t, s) { var n = s(4); e.exports = function (e, t) { if (e) { if ("string" == typeof e) return n(e, t); var s = Object.prototype.toString.call(e).slice(8, -1); return "Object" === s && e.constructor && (s = e.constructor.name), "Map" === s || "Set" === s ? Array.from(e) : "Arguments" === s || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(s) ? n(e, t) : void 0 } } }, function (e, t) { e.exports = function () { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } }, function (e, t, s) { "use strict"; s.r(t); var n = s(5), r = s.n(n); s(1); const a = (e, ...t) => { let s = e; return t.length > 0 && (s += " :: " + JSON.stringify(t)), s }; class i extends Error { constructor(e, t) { super(a(e, t)), this.name = e, this.details = t } } s(2); const o = e => e && "object" == typeof e ? e : { handle: e }; class c { constructor(e, t, s = "GET") { this.handler = o(t), this.match = e, this.method = s } setCatchHandler(e) { this.catchHandler = o(e) } } class h extends c { constructor(e, t, s) { super(({ url: t }) => { const s = e.exec(t.href); if (s && (t.origin === location.origin || 0 === s.index)) return s.slice(1) }, t, s) } } const l = e => new URL(String(e), location.href).href.replace(new RegExp("^" + location.origin), ""); class u { constructor() { this._routes = new Map, this._defaultHandlerMap = new Map } get routes() { return this._routes } addFetchListener() { self.addEventListener("fetch", e => { const { request: t } = e, s = this.handleRequest({ request: t, event: e }); s && e.respondWith(s) }) } addCacheListener() { self.addEventListener("message", e => { if (e.data && "CACHE_URLS" === e.data.type) { const { payload: t } = e.data; 0; const s = Promise.all(t.urlsToCache.map(t => { "string" == typeof t && (t = [t]); const s = new Request(...t); return this.handleRequest({ request: s, event: e }) })); e.waitUntil(s), e.ports && e.ports[0] && s.then(() => e.ports[0].postMessage(!0)) } }) } handleRequest({ request: e, event: t }) { const s = new URL(e.url, location.href); if (!s.protocol.startsWith("http")) return void 0; const n = s.origin === location.origin, { params: r, route: a } = this.findMatchingRoute({ event: t, request: e, sameOrigin: n, url: s }); let i = a && a.handler; const o = e.method; if (!i && this._defaultHandlerMap.has(o) && (i = this._defaultHandlerMap.get(o)), !i) return void 0; let c; try { c = i.handle({ url: s, request: e, event: t, params: r }) } catch (e) { c = Promise.reject(e) } const h = a && a.catchHandler; return c instanceof Promise && (this._catchHandler || h) && (c = c.catch(async n => { if (h) { 0; try { return await h.handle({ url: s, request: e, event: t, params: r }) } catch (e) { n = e } } if (this._catchHandler) return this._catchHandler.handle({ url: s, request: e, event: t }); throw n })), c } findMatchingRoute({ url: e, sameOrigin: t, request: s, event: n }) { const r = this._routes.get(s.method) || []; for (const a of r) { let r; const i = a.match({ url: e, sameOrigin: t, request: s, event: n }); if (i) return r = i, (Array.isArray(i) && 0 === i.length || i.constructor === Object && 0 === Object.keys(i).length || "boolean" == typeof i) && (r = void 0), { route: a, params: r } } return {} } setDefaultHandler(e, t = "GET") { this._defaultHandlerMap.set(t, o(e)) } setCatchHandler(e) { this._catchHandler = o(e) } registerRoute(e) { this._routes.has(e.method) || this._routes.set(e.method, []), this._routes.get(e.method).push(e) } unregisterRoute(e) { if (!this._routes.has(e.method)) throw new i("unregister-route-but-not-found-with-method", { method: e.method }); const t = this._routes.get(e.method).indexOf(e); if (!(t > -1)) throw new i("unregister-route-route-not-registered"); this._routes.get(e.method).splice(t, 1) } } let f; const d = () => (f || (f = new u, f.addFetchListener(), f.addCacheListener()), f); function p(e, t, s) { let n; if ("string" == typeof e) { const r = new URL(e, location.href); 0, n = new c(({ url: e }) => e.href === r.href, t, s) } else if (e instanceof RegExp) n = new h(e, t, s); else if ("function" == typeof e) n = new c(e, t, s); else { if (!(e instanceof c)) throw new i("unsupported-route-type", { moduleName: "workbox-routing", funcName: "registerRoute", paramName: "capture" }); n = e } return d().registerRoute(n), n } const y = { googleAnalytics: "googleAnalytics", precache: "precache-v2", prefix: "workbox", runtime: "runtime", suffix: "undefined" != typeof registration ? registration.scope : "" }, w = e => [y.prefix, e, y.suffix].filter(e => e && e.length > 0).join("-"), g = e => e || w(y.precache), m = e => e || w(y.runtime); function _(e, t) { const s = new URL(e); for (const e of t) s.searchParams.delete(e); return s.href } class v { constructor() { this.promise = new Promise((e, t) => { this.resolve = e, this.reject = t }) } } const b = new Set; function R(e) { return new Promise(t => setTimeout(t, e)) } s(3); function C(e) { return "string" == typeof e ? new Request(e) : e } class U { constructor(e, t) { this._cacheKeys = {}, Object.assign(this, t), this.event = t.event, this._strategy = e, this._handlerDeferred = new v, this._extendLifetimePromises = [], this._plugins = [...e.plugins], this._pluginStateMap = new Map; for (const e of this._plugins) this._pluginStateMap.set(e, {}); this.event.waitUntil(this._handlerDeferred.promise) } fetch(e) { return this.waitUntil((async () => { const { event: t } = this; let s = C(e); if ("navigate" === s.mode && t instanceof FetchEvent && t.preloadResponse) { const e = await t.preloadResponse; if (e) return e } const n = this.hasCallback("fetchDidFail") ? s.clone() : null; try { for (const e of this.iterateCallbacks("requestWillFetch")) s = await e({ request: s.clone(), event: t }) } catch (e) { throw new i("plugin-error-request-will-fetch", { thrownError: e }) } const r = s.clone(); try { let e; e = await fetch(s, "navigate" === s.mode ? void 0 : this._strategy.fetchOptions); for (const s of this.iterateCallbacks("fetchDidSucceed")) e = await s({ event: t, request: r, response: e }); return e } catch (e) { throw n && await this.runCallbacks("fetchDidFail", { error: e, event: t, originalRequest: n.clone(), request: r.clone() }), e } })()) } async fetchAndCachePut(e) { const t = await this.fetch(e), s = t.clone(); return this.waitUntil(this.cachePut(e, s)), t } cacheMatch(e) { return this.waitUntil((async () => { const t = C(e); let s; const { cacheName: n, matchOptions: r } = this._strategy, a = await this.getCacheKey(t, "read"), i = { ...r, cacheName: n }; s = await caches.match(a, i); for (const e of this.iterateCallbacks("cachedResponseWillBeUsed")) s = await e({ cacheName: n, matchOptions: r, cachedResponse: s, request: a, event: this.event }) || void 0; return s })()) } async cachePut(e, t) { const s = C(e); await R(0); const n = await this.getCacheKey(s, "write"); if (!t) throw new i("cache-put-with-no-response", { url: l(n.url) }); const r = await this._ensureResponseSafeToCache(t); if (!r) return !1; const { cacheName: a, matchOptions: o } = this._strategy, c = await self.caches.open(a), h = this.hasCallback("cacheDidUpdate"), u = h ? await async function (e, t, s, n) { const r = _(t.url, s); if (t.url === r) return e.match(t, n); const a = { ...n, ignoreSearch: !0 }, i = await e.keys(t, a); for (const t of i) { if (r === _(t.url, s)) return e.match(t, n) } }(c, n.clone(), ["__WB_REVISION__"], o) : null; try { await c.put(n, h ? r.clone() : r) } catch (e) { throw "QuotaExceededError" === e.name && await async function () { for (const e of b) await e() }(), e } for (const e of this.iterateCallbacks("cacheDidUpdate")) await e({ cacheName: a, oldResponse: u, newResponse: r.clone(), request: n, event: this.event }); return !0 } async getCacheKey(e, t) { if (!this._cacheKeys[t]) { let s = e; for (const e of this.iterateCallbacks("cacheKeyWillBeUsed")) s = C(await e({ mode: t, request: s, event: this.event, params: this.params })); this._cacheKeys[t] = s } return this._cacheKeys[t] } hasCallback(e) { for (const t of this._strategy.plugins) if (e in t) return !0; return !1 } async runCallbacks(e, t) { for (const s of this.iterateCallbacks(e)) await s(t) } *iterateCallbacks(e) { for (const t of this._strategy.plugins) if ("function" == typeof t[e]) { const s = this._pluginStateMap.get(t), n = n => { const r = { ...n, state: s }; return t[e](r) }; yield n } } waitUntil(e) { return this._extendLifetimePromises.push(e), e } async doneWaiting() { let e; for (; e = this._extendLifetimePromises.shift();)await e } destroy() { this._handlerDeferred.resolve() } async _ensureResponseSafeToCache(e) { let t = e, s = !1; for (const e of this.iterateCallbacks("cacheWillUpdate")) if (t = await e({ request: this.request, response: t, event: this.event }) || void 0, s = !0, !t) break; return s || t && 200 !== t.status && (t = void 0), t } } class q { constructor(e = {}) { this.cacheName = m(e.cacheName), this.plugins = e.plugins || [], this.fetchOptions = e.fetchOptions, this.matchOptions = e.matchOptions } handle(e) { const [t] = this.handleAll(e); return t } handleAll(e) { e instanceof FetchEvent && (e = { event: e, request: e.request }); const t = e.event, s = "string" == typeof e.request ? new Request(e.request) : e.request, n = "params" in e ? e.params : void 0, r = new U(this, { event: t, request: s, params: n }), a = this._getResponse(r, s, t); return [a, this._awaitComplete(a, r, s, t)] } async _getResponse(e, t, s) { await e.runCallbacks("handlerWillStart", { event: s, request: t }); let n = void 0; try { if (n = await this._handle(t, e), !n || "error" === n.type) throw new i("no-response", { url: t.url }) } catch (r) { for (const a of e.iterateCallbacks("handlerDidError")) if (n = await a({ error: r, event: s, request: t }), n) break; if (!n) throw r } for (const r of e.iterateCallbacks("handlerWillRespond")) n = await r({ event: s, request: t, response: n }); return n } async _awaitComplete(e, t, s, n) { let r, a; try { r = await e } catch (a) { } try { await t.runCallbacks("handlerDidRespond", { event: n, request: s, response: r }), await t.doneWaiting() } catch (e) { a = e } if (await t.runCallbacks("handlerDidComplete", { event: n, request: s, response: r, error: a }), t.destroy(), a) throw a } } const L = { cacheWillUpdate: async ({ response: e }) => 200 === e.status || 0 === e.status ? e : null }; class T extends q { constructor(e = {}) { super(e), this.plugins.some(e => "cacheWillUpdate" in e) || this.plugins.unshift(L), this._networkTimeoutSeconds = e.networkTimeoutSeconds || 0 } async _handle(e, t) { const s = []; const n = []; let r; if (this._networkTimeoutSeconds) { const { id: a, promise: i } = this._getTimeoutPromise({ request: e, logs: s, handler: t }); r = a, n.push(i) } const a = this._getNetworkPromise({ timeoutId: r, request: e, logs: s, handler: t }); n.push(a); const o = await t.waitUntil((async () => await t.waitUntil(Promise.race(n)) || await a)()); if (!o) throw new i("no-response", { url: e.url }); return o } _getTimeoutPromise({ request: e, logs: t, handler: s }) { let n; return { promise: new Promise(t => { n = setTimeout(async () => { t(await s.cacheMatch(e)) }, 1e3 * this._networkTimeoutSeconds) }), id: n } } async _getNetworkPromise({ timeoutId: e, request: t, logs: s, handler: n }) { let r, a; try { a = await n.fetchAndCachePut(t) } catch (e) { r = e } return e && clearTimeout(e), !r && a || (a = await n.cacheMatch(t)), a } } function k(e, t) { const s = t(); return e.waitUntil(s), s } s(0); function x(e) { if (!e) throw new i("add-to-cache-list-unexpected-type", { entry: e }); if ("string" == typeof e) { const t = new URL(e, location.href); return { cacheKey: t.href, url: t.href } } const { revision: t, url: s } = e; if (!s) throw new i("add-to-cache-list-unexpected-type", { entry: e }); if (!t) { const e = new URL(s, location.href); return { cacheKey: e.href, url: e.href } } const n = new URL(s, location.href), r = new URL(s, location.href); return n.searchParams.set("__WB_REVISION__", t), { cacheKey: n.href, url: r.href } } class P { constructor() { this.updatedURLs = [], this.notUpdatedURLs = [], this.handlerWillStart = async ({ request: e, state: t }) => { t && (t.originalRequest = e) }, this.cachedResponseWillBeUsed = async ({ event: e, state: t, cachedResponse: s }) => { if ("install" === e.type) { const e = t.originalRequest.url; s ? this.notUpdatedURLs.push(e) : this.updatedURLs.push(e) } return s } } } class K { constructor({ precacheController: e }) { this.cacheKeyWillBeUsed = async ({ request: e, params: t }) => { const s = t && t.cacheKey || this._precacheController.getCacheKeyForURL(e.url); return s ? new Request(s) : e }, this._precacheController = e } } let O, M; async function N(e, t) { let s = null; if (e.url) { s = new URL(e.url).origin } if (s !== self.location.origin) throw new i("cross-origin-copy-response", { origin: s }); const n = e.clone(), r = { headers: new Headers(n.headers), status: n.status, statusText: n.statusText }, a = t ? t(r) : r, o = function () { if (void 0 === O) { const e = new Response(""); if ("body" in e) try { new Response(e.body), O = !0 } catch (e) { O = !1 } O = !1 } return O }() ? n.body : await n.blob(); return new Response(o, a) } class S extends q { constructor(e = {}) { e.cacheName = g(e.cacheName), super(e), this._fallbackToNetwork = !1 !== e.fallbackToNetwork, this.plugins.push(S.copyRedirectedCacheableResponsesPlugin) } async _handle(e, t) { const s = await t.cacheMatch(e); return s || (t.event && "install" === t.event.type ? await this._handleInstall(e, t) : await this._handleFetch(e, t)) } async _handleFetch(e, t) { let s; if (!this._fallbackToNetwork) throw new i("missing-precache-entry", { cacheName: this.cacheName, url: e.url }); return s = await t.fetch(e), s } async _handleInstall(e, t) { this._useDefaultCacheabilityPluginIfNeeded(); const s = await t.fetch(e); if (!await t.cachePut(e, s.clone())) throw new i("bad-precaching-response", { url: e.url, status: s.status }); return s } _useDefaultCacheabilityPluginIfNeeded() { let e = null, t = 0; for (const [s, n] of this.plugins.entries()) n !== S.copyRedirectedCacheableResponsesPlugin && (n === S.defaultPrecacheCacheabilityPlugin && (e = s), n.cacheWillUpdate && t++); 0 === t ? this.plugins.push(S.defaultPrecacheCacheabilityPlugin) : t > 1 && null !== e && this.plugins.splice(e, 1) } } S.defaultPrecacheCacheabilityPlugin = { cacheWillUpdate: async ({ response: e }) => !e || e.status >= 400 ? null : e }, S.copyRedirectedCacheableResponsesPlugin = { cacheWillUpdate: async ({ response: e }) => e.redirected ? await N(e) : e }; class A { constructor({ cacheName: e, plugins: t = [], fallbackToNetwork: s = !0 } = {}) { this._urlsToCacheKeys = new Map, this._urlsToCacheModes = new Map, this._cacheKeysToIntegrities = new Map, this._strategy = new S({ cacheName: g(e), plugins: [...t, new K({ precacheController: this })], fallbackToNetwork: s }), this.install = this.install.bind(this), this.activate = this.activate.bind(this) } get strategy() { return this._strategy } precache(e) { this.addToCacheList(e), this._installAndActiveListenersAdded || (self.addEventListener("install", this.install), self.addEventListener("activate", this.activate), this._installAndActiveListenersAdded = !0) } addToCacheList(e) { const t = []; for (const s of e) { "string" == typeof s ? t.push(s) : s && void 0 === s.revision && t.push(s.url); const { cacheKey: e, url: n } = x(s), r = "string" != typeof s && s.revision ? "reload" : "default"; if (this._urlsToCacheKeys.has(n) && this._urlsToCacheKeys.get(n) !== e) throw new i("add-to-cache-list-conflicting-entries", { firstEntry: this._urlsToCacheKeys.get(n), secondEntry: e }); if ("string" != typeof s && s.integrity) { if (this._cacheKeysToIntegrities.has(e) && this._cacheKeysToIntegrities.get(e) !== s.integrity) throw new i("add-to-cache-list-conflicting-integrities", { url: n }); this._cacheKeysToIntegrities.set(e, s.integrity) } if (this._urlsToCacheKeys.set(n, e), this._urlsToCacheModes.set(n, r), t.length > 0) { const e = `Workbox is precaching URLs without revision info: ${t.join(", ")}\nThis is generally NOT safe. Learn more at https://bit.ly/wb-precache`; console.warn(e) } } } install(e) { return k(e, async () => { const t = new P; this.strategy.plugins.push(t); for (const [t, s] of this._urlsToCacheKeys) { const n = this._cacheKeysToIntegrities.get(s), r = this._urlsToCacheModes.get(t), a = new Request(t, { integrity: n, cache: r, credentials: "same-origin" }); await Promise.all(this.strategy.handleAll({ params: { cacheKey: s }, request: a, event: e })) } const { updatedURLs: s, notUpdatedURLs: n } = t; return { updatedURLs: s, notUpdatedURLs: n } }) } activate(e) { return k(e, async () => { const e = await self.caches.open(this.strategy.cacheName), t = await e.keys(), s = new Set(this._urlsToCacheKeys.values()), n = []; for (const r of t) s.has(r.url) || (await e.delete(r), n.push(r.url)); return { deletedURLs: n } }) } getURLsToCacheKeys() { return this._urlsToCacheKeys } getCachedURLs() { return [...this._urlsToCacheKeys.keys()] } getCacheKeyForURL(e) { const t = new URL(e, location.href); return this._urlsToCacheKeys.get(t.href) } async matchPrecache(e) { const t = e instanceof Request ? e.url : e, s = this.getCacheKeyForURL(t); if (s) { return (await self.caches.open(this.strategy.cacheName)).match(s) } } createHandlerBoundToURL(e) { const t = this.getCacheKeyForURL(e); if (!t) throw new i("non-precached-url", { url: e }); return s => (s.request = new Request(e), s.params = { cacheKey: t, ...s.params }, this.strategy.handle(s)) } } const W = () => (M || (M = new A), M); class E extends c { constructor(e, t) { super(({ request: s }) => { const n = e.getURLsToCacheKeys(); for (const e of function* (e, { ignoreURLParametersMatching: t = [/^utm_/, /^fbclid$/], directoryIndex: s = "index.html", cleanURLs: n = !0, urlManipulation: r } = {}) { const a = new URL(e, location.href); a.hash = "", yield a.href; const i = function (e, t = []) { for (const s of [...e.searchParams.keys()]) t.some(e => e.test(s)) && e.searchParams.delete(s); return e }(a, t); if (yield i.href, s && i.pathname.endsWith("/")) { const e = new URL(i.href); e.pathname += s, yield e.href } if (n) { const e = new URL(i.href); e.pathname += ".html", yield e.href } if (r) { const e = r({ url: a }); for (const t of e) yield t.href } }(s.url, t)) { const t = n.get(e); if (t) return { cacheKey: t } } }, e.strategy) } } var I; (function (e) { W().precache(e) })(r()([{ 'revision': null, 'url': 'https://sf1-scmcdn-tos.pstatp.com/goofy/pgcfe/mp/web/resource/common_vendors_5aee6ff0358015adad0d.css' }, { 'revision': null, 'url': 'https://sf1-scmcdn-tos.pstatp.com/goofy/pgcfe/mp/web/resource/common_vendors_5aee6ff0358015adad0d.js' }, { 'revision': null, 'url': 'https://sf1-scmcdn-tos.pstatp.com/goofy/pgcfe/mp/web/resource/constant_vendor_8dfe20d587aa910a85aa.js' }, { 'revision': null, 'url': 'https://sf1-scmcdn-tos.pstatp.com/goofy/pgcfe/mp/web/resource/error_00c4eb5d75d2d259c9cb.js' }, { 'revision': null, 'url': 'https://sf1-scmcdn-tos.pstatp.com/goofy/pgcfe/mp/web/resource/expression-animations_cde2fa3a76907ff88f12.js' }, { 'revision': null, 'url': 'https://sf1-scmcdn-tos.pstatp.com/goofy/pgcfe/mp/web/resource/index_0accfdb360572260d4a9.css' }, { 'revision': null, 'url': 'https://sf1-scmcdn-tos.pstatp.com/goofy/pgcfe/mp/web/resource/index_0accfdb360572260d4a9.js' }, { 'revision': null, 'url': 'https://sf1-scmcdn-tos.pstatp.com/goofy/pgcfe/mp/web/resource/public_be47801d19bc3558f7af.css' }, { 'revision': null, 'url': 'https://sf1-scmcdn-tos.pstatp.com/goofy/pgcfe/mp/web/resource/public_be47801d19bc3558f7af.js' }, { 'revision': null, 'url': 'https://sf1-scmcdn-tos.pstatp.com/goofy/pgcfe/mp/web/resource/register_b977c98b03459e6ab606.css' }, { 'revision': null, 'url': 'https://sf1-scmcdn-tos.pstatp.com/goofy/pgcfe/mp/web/resource/register_b977c98b03459e6ab606.js' }, { 'revision': null, 'url': 'https://sf1-scmcdn-tos.pstatp.com/goofy/pgcfe/mp/web/resource/runtime~error_f4347b2b3def77ee6867.js' }, { 'revision': null, 'url': 'https://sf1-scmcdn-tos.pstatp.com/goofy/pgcfe/mp/web/resource/runtime~index_2e2ce3a8373554af7164.js' }, { 'revision': null, 'url': 'https://sf1-scmcdn-tos.pstatp.com/goofy/pgcfe/mp/web/resource/runtime~public_0bed3d110d8dc2997a78.js' }, { 'revision': null, 'url': 'https://sf1-scmcdn-tos.pstatp.com/goofy/pgcfe/mp/web/resource/runtime~register_3dcc0be2f49547afb382.js' }, { 'revision': null, 'url': 'https://sf1-scmcdn-tos.pstatp.com/goofy/pgcfe/mp/web/resource/vendors_7f16e34d57eec5d4d15c.css' }])), function (e) { const t = W(); p(new E(t, e)) }(I), p((function (e) { return e.url.pathname.indexOf("/mp/agw/media/get_media_info") >= 0 }), new T), p((function (e) { return e.url.pathname.indexOf("garrmodlistv3") >= 0 }), new T), p((function (e) { var t = e.url; return t.hostname.indexOf(".pstatp.com") >= 0 && t.pathname.indexOf("goofy") >= 0 && "https:" === t.protocol }), new class extends q { async _handle(e, t) { let s, n = await t.cacheMatch(e); if (n) 0; else { 0; try { n = await t.fetchAndCachePut(e) } catch (e) { s = e } 0 } if (!n) throw new i("no-response", { url: e.url, error: s }); return n } }), p((function (e) { return e.url.href.indexOf("https://mp.toutiao.com/profile_v4/") >= 0 }), new T) }]);
//# sourceMappingURL=mp-sw.js.map